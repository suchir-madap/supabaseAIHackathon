var m=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var _=Object.prototype.hasOwnProperty;var I=(t,e)=>{for(var r in e)m(t,r,{get:e[r],enumerable:!0})},N=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of A(e))!_.call(t,s)&&s!==r&&m(t,s,{get:()=>e[s],enumerable:!(n=j(e,s))||n.enumerable});return t};var K=t=>N(m({},"__esModule",{value:!0}),t);var Z={};I(Z,{default:()=>Y});module.exports=K(Z);var W=require("@parcel/plugin");async function P({specifier:t,dependency:e}){switch(t){default:return null}}async function w({specifier:t,dependency:e}){if(t.startsWith("./")||t.startsWith("../"))return null;try{return{filePath:require.resolve(t,{paths:[e.resolveFrom]})}}catch{}return null}var o=require("path"),$=require("@parcel/utils");var T=require("fs"),p=require("fs/promises");var h=globalThis.process?.argv||[];var E=()=>globalThis.process?.env||{};var V=new Set(h),S=t=>V.has(t),at=h.filter(t=>t.startsWith("--")&&t.includes("=")).map(t=>t.split("=")).reduce((t,[e,r])=>(t[e]=r,t),{});var lt=S("--dry-run"),b=()=>S("--verbose")||E().VERBOSE==="true",ct=b();async function H(t,e){try{return await(0,p.access)(t,e),!0}catch{return!1}}async function F(t){return H(t,T.constants.R_OK)}var M=require("fs"),v=require("path");var y=[".ts",".tsx",".svelte",".vue",".json",".js",".jsx"],yt=new Set(y);var U=/\S+-loader\S*!\S+/g;function O(t=""){if(U.test(t))throw new Error(`The import path: ${t} is using webpack specific loader import syntax, which isn't supported by Parcel.`)}function x(t){return q(t,"*")}function q(t,e){return t.endsWith(e)&&(t=t.substring(0,t.length-e.length)),t}var B=t=>{try{return(0,M.statSync)(t).isFile()}catch{return!1}};function d(t,e=y){return e.flatMap(r=>[(0,v.resolve)(`${t}${r}`),(0,v.resolve)(t,`index${r}`)]).find(B)}var G=/\.(tsx?)|vue|svelte$/,R=[".ts",".tsx",".svelte",".vue",".json",".css",".scss",".sass",".less",".svg",".js",".jsx"],X=new Set(R),f={pathsMap:null,pathsMapRegex:null};async function k(t){try{let{dependency:e,specifier:r}=t;if(O(e.specifier),!G.test(e.resolveFrom))return null;if(r.startsWith("."))return{filePath:d((0,o.resolve)(e.resolveFrom,"..",r),R)};let s=await L(t);if(s.length===0)return null;J(s);let i=Q(t);return i?{filePath:i}:null}catch{return null}}function J(t){if(f.pathsMap)return;let e=t.reduce((r,n)=>z(n,r),new Map);f.pathsMap=e,f.pathsMapRegex=Array.from(e.entries()).map(r=>[...r,new RegExp(`^${r[0].replace("*",".*")}$`)])}function z(t,e){let{filePath:r,compilerOptions:n}=t,s=n.baseUrl||".",i=n.paths||{},l=(0,o.join)((0,o.dirname)((0,o.join)(r)),s);for(let a in i)e.set(a,i[a].map(c=>(0,o.join)(l,c)));return e}function Q({specifier:t,dependency:e}){let{pathsMap:r,pathsMapRegex:n}=f;if(r.has(t))return C(t,t,r.get(t),e.resolveFrom);let s=n.find(([,,i])=>i.test(t));return s?C(t,s[0],s[1],e.resolveFrom):null}function C(t,e,r,n){for(let s of r){let i=(0,o.resolve)(t.replace(x(e),x(s))),l=(0,o.extname)(i);if(l.length>0&&X.has(l))return i;let a=(0,o.extname)(n),c=[a,...R.filter(g=>g!==a)],u=d(i,c);if(u!==null)return u}return null}async function L(t,e=[],r=0){if(r>42)throw new Error("Something went wrong in loading tsconfig (depth > 42). Circular dependency?");let{options:n,dependency:s,tsconfigPath:i}=t,l=i?[i]:["tsconfig.json","tsconfig.js"],a=await(0,$.loadConfig)(n.inputFS,s.resolveFrom,l,(0,o.join)(process.env.PLASMO_PROJECT_DIR,"lab")),c=a?.config?.compilerOptions;if(!c)return e;let u=a.files[0].filePath,g={compilerOptions:c,filePath:u};try{if(a.config.extends){let D=await F((0,o.resolve)(a.config.extends))?(0,o.resolve)(a.config.extends):require.resolve(a.config.extends,{paths:[s.resolveFrom]});return await L({...t,tsconfigPath:D},[g,...e],++r)}}catch{}return[g,...e]}var Y=new W.Resolver({async resolve(t){return await P(t)||await k(t)||await w(t)||null}});
