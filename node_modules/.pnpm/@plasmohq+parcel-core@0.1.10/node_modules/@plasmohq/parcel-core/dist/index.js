var ae=Object.create;var v=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var le=Object.getOwnPropertyNames;var ue=Object.getPrototypeOf,de=Object.prototype.hasOwnProperty;var he=(e,t)=>{for(var r in t)v(e,r,{get:t[r],enumerable:!0})},q=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of le(t))!de.call(e,i)&&i!==r&&v(e,i,{get:()=>t[i],enumerable:!(s=ne(t,i))||s.enumerable});return e};var l=(e,t,r)=>(r=e!=null?ae(ue(e)):{},q(t||!e||!e.__esModule?v(r,"default",{value:e,enumerable:!0}):r,e)),ce=e=>q(v({},"__esModule",{value:!0}),e);var ye={};he(ye,{INTERNAL_RESOLVE:()=>we,INTERNAL_TRANSFORM:()=>ge,Parcel:()=>I});module.exports=ce(ye);var T=l(require("assert")),G=require("@parcel/core"),z=l(require("@parcel/core/lib/dumpGraphToGraphViz")),H=l(require("@parcel/core/lib/ParcelConfig")),O=require("@parcel/core/lib/projectPath"),V=require("@parcel/core/lib/public/Asset"),U=require("@parcel/core/lib/public/Bundle"),$=l(require("@parcel/core/lib/public/BundleGraph")),K=l(require("@parcel/core/lib/ReporterRunner")),Q=l(require("@parcel/core/lib/requests/ParcelBuildRequest")),J=require("@parcel/core/lib/requests/ParcelConfigRequest"),X=l(require("@parcel/core/lib/requests/ValidationRequest")),g=l(require("@parcel/core/lib/RequestTracker")),w=require("@parcel/core/lib/utils"),C=l(require("@parcel/diagnostic")),E=require("@parcel/events"),Y=require("@parcel/hash"),F=l(require("@parcel/logger")),Z=require("@parcel/source-map"),ee=require("@parcel/utils"),Pe=require("@parcel/watcher"),te=require("abortcontroller-polyfill/dist/cjs-ponyfill"),A=l(require("nullthrows"));var a=l(require("path")),R=require("@parcel/cache"),P=require("@parcel/core/lib/projectPath"),x=require("@parcel/core/lib/requests/ParcelConfigRequest"),S=require("@parcel/fs"),M=require("@parcel/hash"),W=require("@parcel/package-manager"),c=require("@parcel/utils"),pe=["yarn.lock","package-lock.json","pnpm-lock.yaml"];function fe(e){return(0,M.hashString)(`${e.join(",")}-${Date.now()}-${Math.round(Math.random()*100)}`)}async function j(e){let t=e.inputFS||new S.NodeFS,r=e.outputFS||new S.NodeFS,s=t.cwd(),i=r.cwd(),o;e.entries==null||e.entries===""?o=[]:Array.isArray(e.entries)?o=e.entries.map(f=>a.default.resolve(s,f)):o=[a.default.resolve(s,e.entries)];let d=!1;if(o.length===1&&!(0,c.isGlob)(o[0])){let[f]=o;try{d=(await t.stat(f)).isDirectory()}catch{}}let p=(0,c.getRootDir)(d?[a.default.join(o[0],"index")]:o),y=await(0,c.resolveConfig)(t,a.default.join(p,"index"),[...pe],a.default.parse(p).root)||a.default.join(s,"index"),n=a.default.dirname(y),h=e.packageManager||new W.NodePackageManager(t,n),u=a.default.resolve(i,e.cacheDir),b=e.cache??(r instanceof S.NodeFS?new R.LMDBCache(u):new R.FSCache(r,u)),m=e.mode??"development",k=e?.defaultTargetOptions?.shouldOptimize??m==="production",re=e?.defaultTargetOptions?.publicUrl??"/",D=e?.defaultTargetOptions?.distDir!=null?a.default.resolve(s,e?.defaultTargetOptions?.distDir):void 0,_=e.shouldBuildLazily??!1,N=e.shouldContentHash??e.mode==="production";if(_&&N)throw new Error("Lazy bundling does not work with content hashing");let ie=e.env,se=me(e.serveOptions,process.env.PORT);return{config:L(t,n,e.config),defaultConfig:L(t,n,e.defaultConfig),shouldPatchConsole:e.shouldPatchConsole??!1,env:ie,mode:m,shouldAutoInstall:e.shouldAutoInstall??!1,hmrOptions:e.hmrOptions??null,shouldBuildLazily:_,shouldBundleIncrementally:e.shouldBundleIncrementally??!0,shouldContentHash:N,serveOptions:e.serveOptions?{...e.serveOptions,distDir:D??a.default.join(i,"dist"),port:se}:!1,shouldDisableCache:e.shouldDisableCache??!1,shouldProfile:e.shouldProfile??!1,cacheDir:u,entries:o.map(f=>(0,P.toProjectPath)(n,f)),targets:e.targets,logLevel:e.logLevel??"info",projectRoot:n,inputFS:t,outputFS:r,cache:b,packageManager:h,additionalReporters:e.additionalReporters?.map(({packageName:f,resolveFrom:oe})=>({packageName:f,resolveFrom:(0,P.toProjectPath)(n,oe)}))??[],instanceId:fe(o),detailedReport:e.detailedReport,defaultTargetOptions:{shouldOptimize:k,shouldScopeHoist:e?.defaultTargetOptions?.shouldScopeHoist,sourceMaps:e?.defaultTargetOptions?.sourceMaps??!0,publicUrl:re,...D!=null?{distDir:(0,P.toProjectPath)(n,D)}:{},engines:e?.defaultTargetOptions?.engines,outputFormat:e?.defaultTargetOptions?.outputFormat,isLibrary:e?.defaultTargetOptions?.isLibrary}}}function L(e,t,r){if(r!=null)if(a.default.isAbsolute(r)){let s=(0,x.getResolveFrom)(e,t),i=(0,c.relativePath)(a.default.dirname(s),r);return i.startsWith("..")?r:i}else return r}function me(e,t,r=1234){function s(i){let o=Number(i);if(Number.isInteger(o))return o}return e&&e.port!==r?e.port:typeof t<"u"?s(t)??r:r}(0,w.registerCoreWithSerializer)();var ge=Symbol("internal_transform"),we=Symbol("internal_resolve"),I=class{#r;#f;#e;#l=!1;#o;#a;#i;#h=null;#c;#s;#t=new ee.PromiseQueue({maxConcurrent:1});#n;#u;#d=0;#p=new Set;isProfiling;constructor(t){this.#a=t}async _init(){if(this.#l)return;await Z.init,await Y.init;let t=await j(this.#a);this.#h=t;let{config:r}=await(0,J.loadParcelConfig)(t);if(this.#f=new H.default(r,t),this.#a.workerFarm){if(this.#a.workerFarm.ending)throw new Error("Supplied WorkerFarm is ending");this.#e=this.#a.workerFarm}else this.#e=(0,G.createWorkerFarm)({shouldPatchConsole:t.shouldPatchConsole});await t.cache.ensure();let{dispose:s,ref:i}=await this.#e.createSharedReference(t,!1);this.#c=i,this.#o=new E.Disposable,this.#a.workerFarm?this.#o.add(s):this.#o.add(()=>this.#e.end()),this.#n=new E.ValueEmitter,this.#o.add(()=>this.#n.dispose()),this.#r=await g.default.init({farm:this.#e,options:t}),this.#i=new K.default({config:this.#f,options:t,workerFarm:this.#e}),this.#o.add(this.#i),this.#l=!0}async run(){let t=Date.now();this.#l||await this._init();let r=await this._build({startTime:t});if(await this._end(),r.type==="buildFailure")throw new B(r.diagnostics);return r}async _end(){this.#l=!1,await Promise.all([this.#o.dispose(),await this.#r.writeToCache()])}async _startNextBuild(){this.#s=new te.AbortController,await this.#e.callAllWorkers("clearConfigCache",[]);try{let t=await this._build({signal:this.#s.signal});return this.#n.emit({buildEvent:t}),t}catch(t){if(!(t instanceof w.BuildAbortError))throw t}}async watch(t){this.#l||await this._init();let r;t&&(r=this.#n.addListener(({error:o,buildEvent:d})=>t(o,d))),this.#d===0&&(this.#u=await this._getWatcherSubscription(),await this.#i.report({type:"watchStart"}),this.#t.add(()=>this._startNextBuild()),this.#t.run()),this.#d++;let s,i=async()=>{r&&r.dispose(),this.#d--,this.#d===0&&(await(0,A.default)(this.#u).unsubscribe(),this.#u=null,await this.#i.report({type:"watchEnd"}),this.#s.abort(),await this.#t.run(),await this._end())};return{unsubscribe(){return s==null&&(s=i()),s}}}async _build({signal:t=null,startTime:r=Date.now()}={}){this.#r.setSignal(t);let s=(0,A.default)(this.#h);try{s.shouldProfile&&await this.startProfiling(),this.#n.emit({buildEvent:{type:"buildStart"}}),this.#i.report({type:"buildStart"}),this.#r.graph.invalidateOnBuildNodes();let i=(0,Q.default)({optionsRef:this.#c,requestedAssetIds:this.#p,signal:t}),{bundleGraph:o,bundleInfo:d,changedAssets:p,assetRequests:y}=await this.#r.runRequest(i,{force:!0});this.#p.clear(),await(0,z.default)(this.#r.graph,"RequestGraph",g.requestGraphEdgeTypes);let n={type:"buildSuccess",changedAssets:new Map(Array.from(p).map(([h,u])=>[h,(0,V.assetFromValue)(u,s)])),bundleGraph:new $.default(o,(h,u,b)=>U.PackagedBundle.getWithInfo(h,u,b,d.get(h.id)),s),buildTime:Date.now()-r,requestBundle:async h=>{let u=o._graph.getNodeByContentKey(h.id);if((0,T.default)(u?.type==="bundle","Bundle does not exist"),!u.value.isPlaceholder)return{type:"buildSuccess",changedAssets:new Map,bundleGraph:n.bundleGraph,buildTime:0,requestBundle:n.requestBundle};for(let k of u.value.entryAssetIds)this.#p.add(k);this.#t.getNumWaiting()===0&&(this.#s&&this.#s.abort(),this.#t.add(()=>this._startNextBuild()));let m=(await this.#t.run()).filter(Boolean).pop();if(m.type==="buildFailure")throw new B(m.diagnostics);return m}};return await this.#i.report(n),await this.#r.runRequest((0,X.default)({optionsRef:this.#c,assetRequests:y}),{force:y.length>0}),n}catch(i){if(i instanceof w.BuildAbortError)throw i;let o=(0,C.anyToDiagnostic)(i),d={type:"buildFailure",diagnostics:Array.isArray(o)?o:[o]};return await this.#i.report(d),d}finally{this.isProfiling&&await this.stopProfiling(),await this.#e.callAllWorkers("clearConfigCache",[])}}async _getWatcherSubscription(){(0,T.default)(this.#u==null);let t=(0,A.default)(this.#h),r=(0,g.getWatcherOptions)(t);r.ignore.push(process.env.PLASMO_BUILD_DIR);let s=await t.inputFS.watch(t.projectRoot,(i,o)=>{if(i){this.#n.emit({error:i});return}this.#r.respondToFSEvents(o.map(p=>({type:p.type,path:(0,O.toProjectPath)(t.projectRoot,p.path)})))&&this.#t.getNumWaiting()===0&&(this.#s&&this.#s.abort(),this.#t.add(()=>this._startNextBuild()),this.#t.run())},r);return{unsubscribe:()=>s.unsubscribe()}}async startProfiling(){if(this.isProfiling)throw new Error("Parcel is already profiling");F.default.info({origin:"@parcel/core",message:"Starting profiling..."}),this.isProfiling=!0,await this.#e.startProfile()}stopProfiling(){if(!this.isProfiling)throw new Error("Parcel is not profiling");return F.default.info({origin:"@parcel/core",message:"Stopping profiling..."}),this.isProfiling=!1,this.#e.endProfile()}takeHeapSnapshot(){return F.default.info({origin:"@parcel/core",message:"Taking heap snapshot..."}),this.#e.takeHeapSnapshot()}},B=class extends C.default{constructor(t){super({diagnostic:t}),this.name="BuildError"}};0&&(module.exports={INTERNAL_RESOLVE,INTERNAL_TRANSFORM,Parcel});
